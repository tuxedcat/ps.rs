{
	"square": {
		"scope": "rust",
		"prefix": "__seg",
		"body": [
      "struct Seg<T>{",
      "\tn:usize,",
      "\ta:Vec<T>,",
      "}",
      "trait Monoid:Default+Copy{",
      "\tfn op(&self, rhs:Self)->Self;",
      "\tfn upd(&mut self, rhs:Self)->Self;",
      "}",
      "impl<T:Monoid> Seg<T>{",
      "\tfn new(n:usize)->Seg<T>{Seg{n,a:vec![T::default();n*4]}}",
      "\tfn q(&self,s:usize,e:usize)->T{self._q(s,e,0,self.n,1)}",
      "\tfn upd(&mut self,idx:usize,val:T){self._upd(idx,val,0,self.n,1);}",
      "\tfn _q(&self,s:usize,e:usize,cs:usize,ce:usize,ai:usize)->T{",
      "\t\tif ce<=s || e<=cs {",
      "\t\t\treturn T::default()",
      "\t\t}else if s<=cs && ce<=e {",
      "\t\t\tself.a[ai]",
      "\t\t}else{",
      "\t\t\tlet cm=(cs+ce)/2;",
      "\t\t\tself._q(s,e,cs,cm,ai*2).op(self._q(s,e,cm,ce,ai*2+1))",
      "\t\t}",
      "\t}",
      "\tfn _upd(&mut self,idx:usize,val:T,cs:usize,ce:usize,ai:usize)->T{",
      "\t\tif ce<=idx || idx+1<=cs {",
      "\t\t\t",
      "\t\t} else if idx<=cs && ce<=idx+1 {",
      "\t\t\tself.a[ai].upd(val);",
      "\t\t} else {",
      "\t\t\tlet cm=(cs+ce)/2;",
      "\t\t\tself.a[ai]=self._upd(idx,val,cs,cm,ai*2).op(self._upd(idx,val,cm,ce,ai*2+1));",
      "\t\t}",
      "\t\tself.a[ai]",
      "\t}",
      "}",
      "impl Monoid for i64{",
      "\tfn op(&self,rhs:Self)->Self{",
      "\t\tself+rhs",
      "\t}",
      "\tfn upd(&mut self,rhs:Self)->Self{",
      "\t\t*self+=rhs; *self",
      "\t}",
      "}",
    ],
	},
}